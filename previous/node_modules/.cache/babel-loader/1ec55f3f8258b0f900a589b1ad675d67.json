{"ast":null,"code":"import { round } from './parsers.js';\n\nfunction hsvaToRgbaObject(_ref) {\n  var h = _ref.h,\n      s = _ref.s,\n      v = _ref.v,\n      a = _ref.a;\n\n  var _h = h / 360 * 6;\n\n  var _s = s / 100;\n\n  var _v = v / 100;\n\n  var hh = Math.floor(_h);\n  var l = _v * (1 - _s);\n  var c = _v * (1 - (_h - hh) * _s);\n  var d = _v * (1 - (1 - _h + hh) * _s);\n  var module = hh % 6;\n  return {\n    r: round([_v, c, l, l, d, _v][module] * 255),\n    g: round([d, _v, _v, c, l, l][module] * 255),\n    b: round([l, l, d, _v, _v, c][module] * 255),\n    a: round(a, 2)\n  };\n}\n\nfunction hsvaToRgba(color, includeAlpha) {\n  var _hsvaToRgbaObject = hsvaToRgbaObject(color),\n      r = _hsvaToRgbaObject.r,\n      g = _hsvaToRgbaObject.g,\n      b = _hsvaToRgbaObject.b,\n      a = _hsvaToRgbaObject.a;\n\n  if (!includeAlpha) {\n    return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\n  }\n\n  return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(round(a, 2), \")\");\n}\n\nfunction hsvaToHsl(_ref2, includeAlpha) {\n  var h = _ref2.h,\n      s = _ref2.s,\n      v = _ref2.v,\n      a = _ref2.a;\n  var hh = (200 - s) * v / 100;\n  var result = {\n    h: Math.round(h),\n    s: Math.round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),\n    l: Math.round(hh / 2)\n  };\n\n  if (!includeAlpha) {\n    return \"hsl(\".concat(result.h, \", \").concat(result.s, \"%, \").concat(result.l, \"%)\");\n  }\n\n  return \"hsla(\".concat(result.h, \", \").concat(result.s, \"%, \").concat(result.l, \"%, \").concat(round(a, 2), \")\");\n}\n\nfunction formatHexPart(number) {\n  var hex = number.toString(16);\n  return hex.length < 2 ? \"0\".concat(hex) : hex;\n}\n\nfunction hsvaToHex(color) {\n  var _hsvaToRgbaObject2 = hsvaToRgbaObject(color),\n      r = _hsvaToRgbaObject2.r,\n      g = _hsvaToRgbaObject2.g,\n      b = _hsvaToRgbaObject2.b;\n\n  return \"#\".concat(formatHexPart(r)).concat(formatHexPart(g)).concat(formatHexPart(b));\n}\n\nvar CONVERTERS = {\n  hex: hsvaToHex,\n  rgb: function rgb(color) {\n    return hsvaToRgba(color, false);\n  },\n  rgba: function rgba(color) {\n    return hsvaToRgba(color, true);\n  },\n  hsl: function hsl(color) {\n    return hsvaToHsl(color, false);\n  },\n  hsla: function hsla(color) {\n    return hsvaToHsl(color, true);\n  }\n};\n\nfunction convertHsvaTo(format, color) {\n  if (!color) {\n    return \"#000000\";\n  }\n\n  if (!(format in CONVERTERS)) {\n    return CONVERTERS.hex(color);\n  }\n\n  return CONVERTERS[format](color);\n}\n\nexport { convertHsvaTo, hsvaToHex, hsvaToHsl, hsvaToRgba, hsvaToRgbaObject };","map":{"version":3,"mappings":"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","names":["hsvaToRgbaObject","h","s","v","a","_h","_s","_v","hh","Math","floor","l","c","d","module","r","round","g","b","hsvaToRgba","color","includeAlpha","hsvaToHsl","result","formatHexPart","number","hex","toString","length","hsvaToHex","CONVERTERS","rgb","rgba","hsl","hsla","convertHsvaTo","format"],"sources":["/Users/marceloperez/node_modules/@mantine/core/src/components/ColorPicker/converters/converters.ts"],"sourcesContent":["import { HsvaColor, RgbaColor, ColorFormat } from '../types';\nimport { round } from './parsers';\n\nexport function hsvaToRgbaObject({ h, s, v, a }: HsvaColor): RgbaColor {\n  const _h = (h / 360) * 6;\n  const _s = s / 100;\n  const _v = v / 100;\n\n  const hh = Math.floor(_h);\n  const l = _v * (1 - _s);\n  const c = _v * (1 - (_h - hh) * _s);\n  const d = _v * (1 - (1 - _h + hh) * _s);\n  const module = hh % 6;\n\n  return {\n    r: round([_v, c, l, l, d, _v][module] * 255),\n    g: round([d, _v, _v, c, l, l][module] * 255),\n    b: round([l, l, d, _v, _v, c][module] * 255),\n    a: round(a, 2),\n  };\n}\n\nexport function hsvaToRgba(color: HsvaColor, includeAlpha: boolean) {\n  const { r, g, b, a } = hsvaToRgbaObject(color);\n\n  if (!includeAlpha) {\n    return `rgb(${r}, ${g}, ${b})`;\n  }\n\n  return `rgba(${r}, ${g}, ${b}, ${round(a, 2)})`;\n}\n\nexport function hsvaToHsl({ h, s, v, a }: HsvaColor, includeAlpha: boolean) {\n  const hh = ((200 - s) * v) / 100;\n\n  const result = {\n    h: Math.round(h),\n    s: Math.round(hh > 0 && hh < 200 ? ((s * v) / 100 / (hh <= 100 ? hh : 200 - hh)) * 100 : 0),\n    l: Math.round(hh / 2),\n  };\n\n  if (!includeAlpha) {\n    return `hsl(${result.h}, ${result.s}%, ${result.l}%)`;\n  }\n\n  return `hsla(${result.h}, ${result.s}%, ${result.l}%, ${round(a, 2)})`;\n}\n\nfunction formatHexPart(number: number) {\n  const hex = number.toString(16);\n  return hex.length < 2 ? `0${hex}` : hex;\n}\n\nexport function hsvaToHex(color: HsvaColor) {\n  const { r, g, b } = hsvaToRgbaObject(color);\n  return `#${formatHexPart(r)}${formatHexPart(g)}${formatHexPart(b)}`;\n}\n\nconst CONVERTERS: Record<ColorFormat, (color: HsvaColor) => string> = {\n  hex: hsvaToHex,\n  rgb: (color) => hsvaToRgba(color, false),\n  rgba: (color) => hsvaToRgba(color, true),\n  hsl: (color) => hsvaToHsl(color, false),\n  hsla: (color) => hsvaToHsl(color, true),\n};\n\nexport function convertHsvaTo(format: ColorFormat, color: HsvaColor) {\n  if (!color) {\n    return '#000000';\n  }\n\n  if (!(format in CONVERTERS)) {\n    return CONVERTERS.hex(color);\n  }\n\n  return CONVERTERS[format](color);\n}\n"]},"metadata":{},"sourceType":"module"}