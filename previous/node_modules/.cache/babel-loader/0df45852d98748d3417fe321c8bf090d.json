{"ast":null,"code":"import _toConsumableArray from \"/Users/marceloperez/Documents/my-portfolio/my-portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\nfunction groupOptions(_ref) {\n  var data = _ref.data;\n  var sortedData = [];\n  var unGroupedData = [];\n  var groupedData = data.reduce(function (acc, item, index) {\n    if (item.group) {\n      if (acc[item.group]) acc[item.group].push(index);else acc[item.group] = [index];\n    } else {\n      unGroupedData.push(index);\n    }\n\n    return acc;\n  }, {});\n  Object.keys(groupedData).forEach(function (groupName) {\n    sortedData.push.apply(sortedData, _toConsumableArray(groupedData[groupName].map(function (index) {\n      return data[index];\n    })));\n  });\n  sortedData.push.apply(sortedData, _toConsumableArray(unGroupedData.map(function (itemIndex) {\n    return data[itemIndex];\n  })));\n  return sortedData;\n}\n\nfunction getGroupedOptions(data) {\n  var sorted = groupOptions({\n    data: data\n  });\n  var unGrouped = [];\n  var grouped = [];\n  var groupName = null;\n  sorted.forEach(function (item, index) {\n    if (!item.group) {\n      unGrouped.push({\n        type: \"item\",\n        item: item,\n        index: index\n      });\n    } else {\n      if (groupName !== item.group) {\n        groupName = item.group;\n        grouped.push({\n          type: \"label\",\n          label: groupName\n        });\n      }\n\n      grouped.push({\n        type: \"item\",\n        item: item,\n        index: index\n      });\n    }\n  });\n  return {\n    grouped: grouped,\n    unGrouped: unGrouped,\n    items: [].concat(grouped, unGrouped),\n    hasItems: grouped.length > 0 || unGrouped.length > 0\n  };\n}\n\nexport { getGroupedOptions, groupOptions };","map":{"version":3,"mappings":";;AAAO,SAASA,YAAT,OAAgC;AAAA,MAARC,IAAQ,QAARA,IAAQ;AACrC,MAAMC,UAAU,GAAG,EAAnB;AACA,MAAMC,aAAa,GAAG,EAAtB;AACA,MAAMC,WAAW,GAAGH,IAAI,CAACI,MAAL,CAAY,UAACC,GAAD,EAAMC,IAAN,EAAYC,KAAZ,EAAsB;AACpD,QAAID,IAAI,CAACE,KAAT,EAAgB;AACd,UAAIH,GAAG,CAACC,IAAI,CAACE,KAAN,CAAP,EACEH,GAAG,CAACC,IAAI,CAACE,KAAN,CAAH,CAAgBC,IAAhB,CAAqBF,KAArB,EADF,KAGEF,GAAG,CAACC,IAAI,CAACE,KAAN,CAAH,GAAkB,CAACD,KAAD,CAAlB;AACH,KALD,MAKO;AACLL,mBAAa,CAACO,IAAd,CAAmBF,KAAnB;AACD;;AACD,WAAOF,GAAP;AACD,GAVmB,EAUjB,EAViB,CAApB;AAWAK,QAAM,CAACC,IAAP,CAAYR,WAAZ,EAAyBS,OAAzB,CAAiC,UAACC,SAAD,EAAe;AAC9CZ,cAAU,CAACQ,IAAX,iBAAU,qBAASN,WAAW,CAACU,SAAD,CAAX,CAAuBC,GAAvB,CAA2B,UAACP,KAAD;AAAA,aAAWP,IAAI,CAACO,KAAD,CAAf;AAAA,KAA3B,CAAT,EAAV;AACD,GAFD;AAGAN,YAAU,CAACQ,IAAX,iBAAU,qBAASP,aAAa,CAACY,GAAd,CAAkB,UAACC,SAAD;AAAA,WAAef,IAAI,CAACe,SAAD,CAAnB;AAAA,GAAlB,CAAT,EAAV;AACA,SAAOd,UAAP;AACD;;AACM,SAASe,iBAAT,CAA2BhB,IAA3B,EAAiC;AACtC,MAAMiB,MAAM,GAAGlB,YAAY,CAAC;AAAEC,QAAI,EAAJA;AAAF,GAAD,CAA3B;AACA,MAAMkB,SAAS,GAAG,EAAlB;AACA,MAAMC,OAAO,GAAG,EAAhB;AACA,MAAIN,SAAS,GAAG,IAAhB;AACAI,QAAM,CAACL,OAAP,CAAe,UAACN,IAAD,EAAOC,KAAP,EAAiB;AAC9B,QAAI,CAACD,IAAI,CAACE,KAAV,EAAiB;AACfU,eAAS,CAACT,IAAV,CAAe;AAAEW,YAAI,EAAE,MAAR;AAAgBd,YAAI,EAAJA,IAAhB;AAAsBC,aAAK,EAALA;AAAtB,OAAf;AACD,KAFD,MAEO;AACL,UAAIM,SAAS,KAAKP,IAAI,CAACE,KAAvB,EAA8B;AAC5BK,iBAAS,GAAGP,IAAI,CAACE,KAAjB;AACAW,eAAO,CAACV,IAAR,CAAa;AAAEW,cAAI,EAAE,OAAR;AAAiBC,eAAK,EAAER;AAAxB,SAAb;AACD;;AACDM,aAAO,CAACV,IAAR,CAAa;AAAEW,YAAI,EAAE,MAAR;AAAgBd,YAAI,EAAJA,IAAhB;AAAsBC,aAAK,EAALA;AAAtB,OAAb;AACD;AACF,GAVD;AAWA,SAAO;AACLY,WAAO,EAAPA,OADK;AAELD,aAAS,EAATA,SAFK;AAGLI,SAAK,YAAMH,OAAN,EAAkBD,SAAlB,CAHA;AAILK,YAAQ,EAAEJ,OAAO,CAACK,MAAR,GAAiB,CAAjB,IAAsBN,SAAS,CAACM,MAAV,GAAmB;AAJ9C,GAAP;AAMF","names":["groupOptions","data","sortedData","unGroupedData","groupedData","reduce","acc","item","index","group","push","Object","keys","forEach","groupName","map","itemIndex","getGroupedOptions","sorted","unGrouped","grouped","type","label","items","hasItems","length"],"sources":["/Users/marceloperez/node_modules/@mantine/core/src/utils/group-options/group-options.ts"],"sourcesContent":["interface GroupData {\n  data: { group?: string }[];\n}\n\nexport function groupOptions({ data }: GroupData) {\n  const sortedData = [];\n  const unGroupedData = [];\n  const groupedData = data.reduce((acc, item, index) => {\n    if (item.group) {\n      if (acc[item.group]) acc[item.group].push(index);\n      else acc[item.group] = [index];\n    } else {\n      unGroupedData.push(index);\n    }\n    return acc;\n  }, {});\n\n  Object.keys(groupedData).forEach((groupName) => {\n    sortedData.push(...groupedData[groupName].map((index) => data[index]));\n  });\n\n  sortedData.push(...unGroupedData.map((itemIndex) => data[itemIndex]));\n\n  return sortedData;\n}\n\nexport function getGroupedOptions<T extends any[]>(data: T) {\n  type Item = { type: 'item'; item: T[number]; index: number };\n  type Label = { type: 'label'; label: string };\n\n  const sorted = groupOptions({ data });\n  const unGrouped: Item[] = [];\n  const grouped: (Item | Label)[] = [];\n  let groupName = null;\n\n  sorted.forEach((item, index) => {\n    if (!item.group) {\n      unGrouped.push({ type: 'item', item, index });\n    } else {\n      if (groupName !== item.group) {\n        groupName = item.group;\n        grouped.push({ type: 'label', label: groupName });\n      }\n      grouped.push({ type: 'item', item, index });\n    }\n  });\n\n  return {\n    grouped,\n    unGrouped,\n    items: [...grouped, ...unGrouped],\n    hasItems: grouped.length > 0 || unGrouped.length > 0,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}