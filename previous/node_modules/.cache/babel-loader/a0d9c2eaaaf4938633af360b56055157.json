{"ast":null,"code":"import { useLayoutEffect as e } from \"@radix-ui/react-use-layout-effect\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as t from \"react\";\nexport const Presence = u => {\n  const {\n    present: o,\n    children: i\n  } = u,\n        s = function (n) {\n    const [u, o] = t.useState(),\n          i = t.useRef({}),\n          s = t.useRef(n),\n          c = t.useRef(\"none\"),\n          a = n ? \"mounted\" : \"unmounted\",\n          [d, m] = function (e, n) {\n      return t.useReducer((e, t) => {\n        const r = n[e][t];\n        return null != r ? r : e;\n      }, e);\n    }(a, {\n      mounted: {\n        UNMOUNT: \"unmounted\",\n        ANIMATION_OUT: \"unmountSuspended\"\n      },\n      unmountSuspended: {\n        MOUNT: \"mounted\",\n        ANIMATION_END: \"unmounted\"\n      },\n      unmounted: {\n        MOUNT: \"mounted\"\n      }\n    });\n\n    return t.useEffect(() => {\n      const e = r(i.current);\n      c.current = \"mounted\" === d ? e : \"none\";\n    }, [d]), e(() => {\n      const e = i.current,\n            t = s.current;\n\n      if (t !== n) {\n        const u = c.current,\n              o = r(e);\n        if (n) m(\"MOUNT\");else if (\"none\" === o || \"none\" === (null == e ? void 0 : e.display)) m(\"UNMOUNT\");else {\n          const e = u !== o;\n          m(t && e ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n        }\n        s.current = n;\n      }\n    }, [n, m]), e(() => {\n      if (u) {\n        const e = e => {\n          const n = r(i.current).includes(e.animationName);\n          e.target === u && n && m(\"ANIMATION_END\");\n        },\n              n = e => {\n          e.target === u && (c.current = r(i.current));\n        };\n\n        return u.addEventListener(\"animationstart\", n), u.addEventListener(\"animationcancel\", e), u.addEventListener(\"animationend\", e), () => {\n          u.removeEventListener(\"animationstart\", n), u.removeEventListener(\"animationcancel\", e), u.removeEventListener(\"animationend\", e);\n        };\n      }\n\n      m(\"ANIMATION_END\");\n    }, [u, m]), {\n      isPresent: [\"mounted\", \"unmountSuspended\"].includes(d),\n      ref: t.useCallback(e => {\n        e && (i.current = getComputedStyle(e)), o(e);\n      }, [])\n    };\n  }(o),\n        c = \"function\" == typeof i ? i({\n    present: s.isPresent\n  }) : t.Children.only(i),\n        a = n(s.ref, c.ref);\n\n  return \"function\" == typeof i || s.isPresent ? /*#__PURE__*/t.cloneElement(c, {\n    ref: a\n  }) : null;\n};\n\nfunction r(e) {\n  return (null == e ? void 0 : e.animationName) || \"none\";\n}\n\nPresence.displayName = \"Presence\";","map":{"version":3,"mappings":"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","names":["Presence","props","present","children","presence","node","setNode","React","useState","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","useReducer","event","nextState","$d88c0747af12355025ed3195fb48c68a$export$useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","useEffect","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","prevAnimationName","display","isAnimating","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","handleAnimationStart","addEventListener","removeEventListener","isPresent","ref","useCallback","getComputedStyle","usePresence","child","Children","only","useComposedRefs","cloneElement","displayName"],"sources":["/Users/marceloperez/node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/Presence.tsx","/Users/marceloperez/node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/useStateMachine.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  present: boolean;\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send('ANIMATION_END');\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}